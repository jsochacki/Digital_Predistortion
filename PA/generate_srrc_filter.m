function varargout = generate_srrc_filter(implementation_type, ...
                                          filter_length_in_symbols, ...
                                          rolloff_rate, ...
                                          digital_over_sampling_rate)
%generate_srrc_filter Time domain generation of srrc filter
%Provides h in time domain
%
%   INPUT implementation_type: firrcosw - As described in the DVBS2
%                                Standard and what is on Wikipedia
%                              firrcosm - As implemented in matlab core
%                                code for unity gain
%                              firrcoswu - As described in the DVBS2
%                                Standard and what is on Wikipedia
%                                but scaled to unity gain
%                              firrcosmu - As implemented in matlab core
%                                code for unity gain but scaled to actual
%                                unity gain as matlabs implementation is
%                                not perfect unity
%   NOTE: For the same length of filter the EVM of the matlab based design
%           is typically 0.5 dB better
%   INPUT filter_length_in_symbols: The length of the filter in symbols
%   INPUT rolloff_rate: The rollof rate of the filter (alpha) e.g. 0.25 for
%                         25% rolloff
%   INPUT digital_over_sampling_rate: The oversampling rate of the filter
%
%   OUTPUT h: Time domain coefficients

altered_order = 0;
% DVBS2 / Wikipedia Implementation
if (strcmp(implementation_type,'firrcosw') ...
   || strcmp(implementation_type,'firrcoswu'))

	order = filter_length_in_symbols * digital_over_sampling_rate;
	if mod(order, 2)
		order = order + 1;
        altered_order = 1;
		sprintf(['The filter_length_in_symbols and digital_over_sampling_rate\n', ...
			    'that was provided made the filter order odd so the\n', ...
			    'order was increased by 1'])
	end
	symbol_rate = 1;
	Ts = 1 / symbol_rate;
	Fc = symbol_rate / 2;
	time_step = 1 / digital_over_sampling_rate;
	h = zeros(1, floor(order / 2) + 1);
	h(1) = (1 / Ts) * ...
				 (1 - rolloff_rate + ((4 * rolloff_rate) / pi));
	for index = 1:1:(length(h) - 1)
		tx = (index * Ts) / digital_over_sampling_rate;
		if (tx == (1 / (4 * rolloff_rate)))
			h(index + 1) = (rolloff_rate / (Ts * sqrt(2))) * ...
				( ...
				  ((1 + (2 / pi)) * ...
				   sin(pi / (4 * rolloff_rate))) + ...
				  ((1 - (2 / pi)) * ...
				   cos(pi / (4 * rolloff_rate))) ...
				);
		else
			h(index + 1) = (1 / Ts) * ...
				( ...
				 ( sin(pi * (tx * (1 - rolloff_rate))) + ...
				   (4 * rolloff_rate * tx * ...
					   cos(pi * (tx * (1 + rolloff_rate)))) ...
				 ) / ...
				 (pi * tx * ...
					 (1 - power(4 * rolloff_rate * tx, 2)) ...
				 ) ...
				);
		end
	end
	h = [fliplr(h(2:1:end)),h];
            
% Matlab Unity Gain Implementation
elseif (strcmp(implementation_type,'firrcosm') ...
        || strcmp(implementation_type,'firrcosmu'))

	% Constants Set Up
	symbol_rate = 1;
	Fc = symbol_rate / 2;
	Fs = digital_over_sampling_rate;
	deps = eps('double');

	% Constants Calculation
	order = filter_length_in_symbols * digital_over_sampling_rate;
	time_step = 1 / Fs;

	if mod(order, 2)
        order = order + 1;
        altered_order = 1;
		sprintf(['The filter_length_in_symbols and digital_over_sampling_rate\n', ...
			     'that was provided made the filter order odd so the\n', ...
			     'order was increased by 1'])
	end

	% Half Array Initialization
	n = (0:1:(floor(order / 2) + 1)) * time_step;
	h = zeros(1, floor(order / 2) + 1);

	% Center Tap Value
	h(1) = - ( ...
                (sqrt(2 * Fc) / (pi * Fs)) * ...
                ((pi * (rolloff_rate - 1)) - (4 * rolloff_rate )) ...
              );

	ind = abs(abs(8 * rolloff_rate * Fc * n) - 1.0) < sqrt(deps);
	index = find(ind ~= 0);

	if length(index) == 1
		h(index(1)) = ...
			(sqrt(2 * Fc) / (2 * pi * Fs)) * ...
			( ((pi * (rolloff_rate + 1) ) * ...
			  (sin(pi * (rolloff_rate + 1) / ...
					  (4 * rolloff_rate))) ...
			  ) - ...
                  (4 * rolloff_rate * ...
                   sin(pi * (rolloff_rate - 1) / (4 * rolloff_rate)) ...
			  ) + ...
			  ( ...
				  (pi * (rolloff_rate - 1)) * ...
				  cos(pi * (rolloff_rate - 1) / (4 * rolloff_rate)) ...
			  ) ...
			);
	else
		sprintf(['This should not occur with this filter design ever', ...
			     'you likely have a numerical error with the type', ...
			     'you are using and the inferred types'])
	end
	
	index = find(h == 0);

	h(index) = ...
		(-4 * rolloff_rate / Fs) * ...
		( cos((1 + rolloff_rate) * 2 * pi * Fc * n(index)) + ...
			  ( sin((1 - rolloff_rate) * 2 * pi * Fc * n(index)) ./ ...
				(8 * rolloff_rate * Fc * n(index)) ...
			  ) ...
		) ./ ...
		(pi * sqrt(1 / (2 * Fc)) * ...
			((power((8 * rolloff_rate * Fc * n(index)), 2)) - 1) ...
		);
	h = h * sqrt(2 * Fc);
    h = [fliplr(h(2:1:end)),h];
end

% check against matlab filter for accuracy
mlh=firrcos((filter_length_in_symbols * digital_over_sampling_rate) + altered_order, ...
        1/2, ...
        rolloff_rate, ...
        digital_over_sampling_rate, ...
        'rolloff', ...
        'sqrt'); 

if strcmp(implementation_type,'firrcosw')
    %Need to normalize as there will be gain in this h version
    h2 = h ./max(abs(h));    
    mlh = mlh ./max(abs(mlh));
elseif strcmp(implementation_type,'firrcosm')
    %Nothing to do here
    h2 = h;
end

if (strcmp(implementation_type,'firrcoswu') ...
    || strcmp(implementation_type,'firrcosmu'))
    %Need to properly scale to unity gain
    h = h ./sum(h);
    h2 = h;
    mlh = mlh ./sum(mlh);
end

MSE = 10*log10((1/length(h2))*((h2 - mlh)*(h2 - mlh)'));    

error = 1.0* (MSE > -200);

if (nargout >= 1)
varargout{1} = h;
end
if (nargout >= 2)
varargout{2} = error;
end

end

